# CLAUDE.md Template

Template for generating `CLAUDE.md` at project root — synthesized from `.planning/codebase/*.md` analysis documents.

**Purpose:** Auto-generate a prescriptive CLAUDE.md that Claude Code loads every session, making codebase rules always available — not just during DevFlow workflows.

**Source documents:** STACK.md, ARCHITECTURE.md, STRUCTURE.md, CONVENTIONS.md, TESTING.md, PATTERNS.md, INTEGRATIONS.md, CONCERNS.md

---

## File Template

```markdown
<!-- DEVFLOW:START - Auto-generated by /df:map-codebase. Edit between these markers will be overwritten. -->

# Project Overview

[1-3 lines: what this project is, primary language/framework, runtime]

# Code Style

[Prescriptive rules from CONVENTIONS.md — naming, formatting, imports, error handling]
[Use imperative tone: "Use camelCase for functions", "Never use var"]

# Architecture Rules

[Key patterns from ARCHITECTURE.md — layers, data flow, boundaries]
[Where to put business logic, how components communicate, state management approach]

# File Placement

[From STRUCTURE.md — where new files go, naming conventions, directory purpose]
[Example: "Place API routes in src/routes/, name files kebab-case.ts"]

# Testing Requirements

[From TESTING.md — framework, file location, patterns, what to test]
[Example: "Write tests in *.test.ts next to source. Use vitest. Mock external APIs."]

# Code Patterns

[From PATTERNS.md — representative code snippets showing "this is how we write code here"]
[Include 2-3 most important patterns with brief file references]
[Example: "Service pattern — see src/services/user.service.ts", "Test pattern — see src/services/user.service.test.ts"]

# External Integrations

[From INTEGRATIONS.md — APIs, databases, auth providers, key patterns]
[Only include if meaningful integrations exist. Skip for simple projects.]

# Critical Warnings

[From CONCERNS.md + INTEGRATIONS.md — things that break easily, tech debt traps]
[Example: "Never modify the auth middleware without updating both API and webhook paths"]

# Common Commands

[From STACK.md — build, test, lint, dev server commands]
[Example: "npm run dev — start dev server", "npm test — run all tests"]

<!-- DEVFLOW:END -->
```

---

## Good Example

```markdown
<!-- DEVFLOW:START - Auto-generated by /df:map-codebase. Edit between these markers will be overwritten. -->

# Project Overview

Task management API built with TypeScript + Express on Node.js 20. PostgreSQL database with Prisma ORM. Deployed to AWS ECS.

# Code Style

- Use camelCase for functions and variables, PascalCase for types and interfaces
- Use single quotes, semicolons required, 2-space indentation (Prettier enforced)
- Import order: external packages → internal modules (@/) → relative imports → type imports
- Throw errors at point of failure, catch at route handler boundaries
- Use pino logger from `src/lib/logger.ts` — never use console.log
- Name files kebab-case: `user-service.ts`, `auth-middleware.ts`
- Max 3 function parameters — use options object for more

# Architecture Rules

- Three-layer architecture: routes → services → repositories
- Business logic lives in `src/services/` — never in route handlers or repositories
- Repositories handle all database access via Prisma — services never import Prisma directly
- Use dependency injection: services accept repositories as constructor parameters
- Events go through `src/lib/event-bus.ts` — no direct cross-service calls for side effects

# File Placement

- API routes: `src/routes/{resource}.routes.ts`
- Services: `src/services/{resource}.service.ts`
- Repositories: `src/repositories/{resource}.repository.ts`
- Types/interfaces: `src/types/{domain}.types.ts`
- Middleware: `src/middleware/{name}.middleware.ts`
- Shared utilities: `src/lib/{name}.ts`

# Testing Requirements

- Use vitest for all tests. Files go next to source: `user.service.test.ts`
- Mock external services (database, APIs) — never hit real services in tests
- Test services through their public methods, not internal helpers
- Run tests: `npm test` — run with coverage: `npm run test:coverage`
- Required coverage: 80% for services, 60% for routes

# Code Patterns

- Service pattern: `src/services/user.service.ts` — constructor injection, async methods, error boundaries
- Test pattern: `src/services/user.service.test.ts` — describe/it blocks, repository mocks, assertion style
- Route pattern: `src/routes/user.routes.ts` — express Router, try/catch, service delegation

# Critical Warnings

- The `src/middleware/auth.ts` rate limiter shares state with `src/routes/webhook.routes.ts` — changing rate limits affects both API and webhook paths
- Prisma migrations must run before deploy — `npx prisma migrate deploy` in CI
- The `LEGACY_` prefixed environment variables are read by the billing service — do not remove without coordinating with billing team
- `src/services/notification.service.ts` has a retry queue that silently drops messages after 3 failures — add monitoring before relying on it for critical notifications

# Common Commands

- `npm run dev` — start dev server with hot reload
- `npm test` — run all tests
- `npm run test:coverage` — run tests with coverage report
- `npm run lint` — run ESLint
- `npm run build` — compile TypeScript to dist/
- `npx prisma migrate dev` — create and apply new migration
- `npx prisma studio` — open database GUI

<!-- DEVFLOW:END -->
```

---

## Guidelines

**Tone — prescriptive, not descriptive:**
- Write rules, not observations
- Good: "Use camelCase for functions"
- Bad: "The codebase uses camelCase for functions"
- Good: "Never import Prisma directly in services — use repositories"
- Bad: "Prisma is accessed through repository classes"

**Brevity matters:**
- CLAUDE.md is auto-loaded every session — every line costs context tokens
- Aim for 80-150 lines total
- One rule per bullet point, no multi-paragraph explanations
- Skip sections that have nothing meaningful to say (e.g., no integrations = skip that section)

**Concreteness wins:**
- Include actual file paths: `src/services/`, not "the services directory"
- Include actual commands: `npm test`, not "run the tests"
- Include actual patterns: `*.test.ts`, not "test files"
- Include actual names: `pino`, not "the logging library"

**What to include vs. skip:**
- Include: Rules that Claude would otherwise guess wrong about
- Include: Patterns that differ from common defaults
- Include: Things that break if done wrong (Critical Warnings)
- Skip: Obvious conventions (e.g., "use TypeScript" in a TS project)
- Skip: Rarely relevant details (deployment infra, CI pipeline specifics)
- Skip: Sections where the codebase has nothing notable

**Source mapping (which docs inform which sections):**
- Project Overview ← STACK.md, ARCHITECTURE.md
- Code Style ← CONVENTIONS.md
- Architecture Rules ← ARCHITECTURE.md
- File Placement ← STRUCTURE.md
- Testing Requirements ← TESTING.md
- Code Patterns ← PATTERNS.md
- External Integrations ← INTEGRATIONS.md
- Critical Warnings ← CONCERNS.md, INTEGRATIONS.md
- Common Commands ← STACK.md

**Merge strategy:**
- DevFlow owns content between `<!-- DEVFLOW:START -->` and `<!-- DEVFLOW:END -->` markers
- User content outside markers is always preserved
- If CLAUDE.md exists with markers: replace between markers only
- If CLAUDE.md exists without markers: prepend DevFlow section (with markers) above existing content
- If no CLAUDE.md: create fresh file with markers wrapping all content
